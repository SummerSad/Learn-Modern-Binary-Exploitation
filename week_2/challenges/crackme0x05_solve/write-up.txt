Use radare2

	r2 ./crackme0x05

In radare2

	aa
	pdf@sym.main

0x08048590      e833ffffff     sym.check ()

In radare2

	pdf@sym.check

0x080484ce      c745f8000000.  dword [local_8h] = 0
0x080484d5      c745f4000000.  dword [local_ch] = 0
0x080484dc      8b4508         eax = dword [arg_8h]        ; [0x8:4]=-1 ; 8
0x080484df      890424         dword [esp] = eax
0x080484e2      e89dfeffff     sym.imp.strlen ()           ; size_t strlen(const char *s)
0x080484e7      3945f4         var = dword [local_ch] - eax ; [0x13:4]=-1 ; 19
0x080484ea      7346           jae 0x8048532

Look like local_8h is strlen, local_ch is counter
If counter > strlen => bad boy

0x0804850d      e892feffff     sym.imp.sscanf ()           ; int sscanf(const char *s, const char *format,   ...)
0x08048512      8b55fc         edx = dword [local_4h]
0x08048515      8d45f8         eax = dword [local_8h]
0x08048518      0110           dword [eax] += edx
0x0804851a      837df810       var = dword [local_8h] - 0x10 ; [0x10:4]=-1 ; 16
0x0804851e      750b           if (var) goto 0x804852b
0x08048520      8b4508         eax = dword [arg_8h]        ; [0x8:4]=-1 ; 8
0x08048523      890424         dword [esp] = eax
0x08048526      e859ffffff     sym.parell ()

var = sum of digits[0..counter]
At some point, var must be 16 to go sym.parell()
otherwise, bad boy :(

Example 88, 881, 882, 883, 448, 4480, ... (8 + 8 = 16, 4 + 4 + 8 = 16)

In radare2

	pdf@sym.parell

|           0x080484a7      83e001         eax &= 1
|           0x080484aa      85c0           var = eax & eax
|       ,=< 0x080484ac      7518           if (var) goto 0x80484c6
|       |   0x080484ae      c704246b8604.  dword [esp] = str.Password_OK ; [0x804866b:4]=0x73736150 ; "Password OK!\n"
|       |   0x080484b5      e8dafeffff     sym.imp.printf ()           ; int printf(const char *format)
|       |   0x080484ba      c70424000000.  dword [esp] = 0
|       |   0x080484c1      e8eefeffff     sym.imp.exit ()             ; void exit(int status)
|       `-> 0x080484c6      c9             leave

eax &= 1 is a check if eax is even or oddd
If eax is even => eax &= 1 change eax to 0
Otherwise eax is changed to 1
var must be 0 for good boy => eax must be even
=> the digit which end the sequence must be even

Example 88 is OK, but 79 is not OK (although 7 + 9 = 16)
881 is OK because 8 is the end-digit not 1 (8 + 8 = 16)
772 is OK because 2 is the end-digit (7 + 7 + 2 = 16)

Password is 88, 881, 882, 484, 772, 7724, ...
